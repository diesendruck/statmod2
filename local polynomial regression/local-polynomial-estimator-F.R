# Stat Mod 2 - Local Linear Estimator (p.6)
# 
# This script fits the local linear estimator using a Gaussian kernel for a
# specified choice of bandwidth h. (Chooses a bandwidth using LOOCV.) Also
# smooths log(resid^2) to fix heteroscedasticity, and smooths with bootstrapped
# variances obtained through bootstrapping.
#
# Author: Maurice Diesendruck
# Last updated: 2015-03-03

Main <- function() {
  # Performs local polynomial regression, choosing a bandwidth with LOOCV.
  #
  # Args:
  #   NA: Nona.
  #
  # Returns:
  #   NA: Plots outputs.
  d <- GetData()
  
  # ---------Regular smoothing---------#
  
  # Smooth and plot residuals for avg bill vs temp.
  hbs <- PerformLOOCV(d, bandwidth=NULL)
  H <- hbs[[1]]
  bw <- hbs[[2]]
  yhat <- H %*% d$y
  r <- CalcResid(d, yhat, H, bw, opt=NULL)
  
  # ---------Residual smoothing---------#
  
  # Prep residual data.
  res.data <- data.frame(cbind(d$x, log(r^2)))
  names(res.data) <- c("x", "y")
  
  # Smooth and plot residuals for log of squared residuals vs temp.
  res.hbs <- PerformLOOCV(res.data, bandwidth=NULL)
  res.H <- res.hbs[[1]]
  res.bw <- res.hbs[[2]]
  res.yhat <- res.H %*% res.data$y
  res.r <- CalcResid(res.data, res.yhat, res.H, res.bw, opt=NULL)
  
  # ---------Bootstrap smoothing---------#
  
  # Bootstrap samples of X, and compute various yhat estimates. Compute
  # variance for estimates at each x.i, and use that to make confidence
  # interval for each x.i.
  iter <- 10
  n <- length(d$y)
  booted.yhats <- matrix(NA, nrow=n, ncol=iter)
  
  for (i in 1:iter) {
    # Bootstrap ("bs") by resampling data.
    indices <- sample(1:n, replace=TRUE)
    bs.d <- GetData()[indices, ]
    bs.d <- bs.d[order(bs.d[, 1]), ]
    
    # Get yhats for the resampled set.
    bs.hbs <- PerformLOOCV(bs.d, bandwidth=NULL)
    bs.H <- bs.hbs[[1]]
    bs.yhat <- bs.H %*% bs.d$y
    booted.yhats[, i] <- bs.yhat
  }
  booted.vars <- apply(booted.yhats, 1, var)
  booted.r <- CalcResid(d, yhat, H, bw, opt=booted.vars)
  
}

GetData <- function() {
  # Prepares data from file.
  #
  # Args:
  #   NA: None.
  #
  # Returns:
  #   data: A matrix of data.
  setwd("~/Google Drive/2. SPRING 2015/STAT MOD 2 - Prof Scott/local polynomial regression")
  data <- read.csv("utilities.csv", header=T, sep=",")
  
  # Add column for average daily bill.
  data <- within(data, {
    y <- gasbill/billingdays
    x <- temp
  })
  
  data <- data[order(data[, 1]), ]
  attach(data)
  #plot(x, y)
  
  return (data)
}

PerformLOOCV <- function(data, bandwidth) {
  # Computes hat matrix and LOOCV score for a given bandwidth; or, if no
  # bandwidth is chosen, finds optimal bandwidth (one with lowest LOOCV score)
  # and then computes hat matrix.
  # 
  # Args:
  #   data: The full data set.
  #   bandwidth: The bandwidth for the model. Find optimal by leaving NULL.
  #
  # Returns:
  #   hat.bw.score: A list of hat matrix, bandwidth, and loocv score.
  x <- data[, c("x")]
  y <- data[, c("y")]

  hat.matrix <- function(bw) t(sapply(x, function(z) Weight(z, bw)))
  loocv.score <- function(bw) {
    H <- hat.matrix(bw)
    yhat <- H%*%y
    score <- sum(((y-yhat)/(1-diag(H)))^2)
    return (score)
  }
  
  if (!is.null(bandwidth)) {
    bw <- bandwidth
  } else {
    bw <- optimize(loocv.score, interval=c(0, max(x)-min(x)))$minimum
  }

  H <- hat.matrix(bw)
  score <- loocv.score(bw)
  hat.bw.score <- list(H, bw, score)
  return (hat.bw.score)
}

Weight <- function(z, bandwidth, kernel=dnorm) {
  # For estimation at point z, gives the Gaussian-smoothed weights that will be
  # applied to every x (including itself). This is equivalent to a row of the
  # Hat Matrix.
  #
  # Args:
  #   z: Vector of X values to receive weights.
  #   bandwidth: A neighborhood around each requested x.star, used to average 
  #     the area under the smoother function.
  #   kernel: The function used to define the type of smoothing around z.
  #
  # Returns:
  #   weight: The weight of the y that corresponds to x.i.
  dif <- x-z
  weight <- kernel(dif/bandwidth)/bandwidth
  s1 <- sum(weight*dif)
  s2 <- sum(weight*dif^2)
  weight <- weight*(s2-dif*s1)
  weight <- weight/sum(weight)
  return (weight)
}

CalcResid <- function(data, yhat, H, bw, opt) {
  # Calculates and plots residuals for yhat.
  # 
  # Args:
  #   data: The full data set.
  #   yhat: The predictions generated by multiplying the hat matrix with y.
  #   H: The hat matrix.
  #   bw: The bandwidth.
  #   opt: An optional parameter, used here to pass bootstrapped variances.
  #
  # Returns:
  #   r: Vector of residuals.
  x <- data[, c("x")]
  y <- data[, c("y")]
  n <- length(y)
  
  # Compute residuals for y prediction.
  r <- y-yhat
  
  # Compute variance using formula (probably p.6 of Ex3).
  if (!is.null(opt)) {
    variance <- opt
  } else {
    variance <- sum(r*r)/(n-2*sum(diag(H))-sum(diag(t(H)%*%H)))
  }
  se <- sqrt(variance*rowSums(H^2))
  
  # Plot residuals.
  plot(x, r, xlab="Temp", ylab="Res. on Avg. Daily Bill",
       main=paste("Residuals for Bandwidth =", round(bw, 2)))
  
  # Plot prediction with 95% confidence interval lines.
  plot(x, y, col="gray", xlab="Temp", ylab="Y",
       main=paste("Local Polynomial Regression with 95% CI, Bandwidth =",
                  round(bw, 2)))
  t <- qt(c(0.025, 0.975), 116)
  lines(x, yhat, col="grey20", lwd="2")
  lines(x, yhat+t[1]*se, col="dodgerblue3", lwd="2", lty=3)
  lines(x, yhat+t[2]*se, col="steelblue1", lwd="2", lty=3)
  
  return (r)
}

Main()





